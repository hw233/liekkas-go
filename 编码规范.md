# 编码规范
### 一、空指针
#### 1. 指针作为参数传入必须判断空指针
**正确示例**:
```go
func SetUser(user *User) {
    if user == nil{
        return  
    }
    
    // handle user
}
```
#### 2. 利用第二返回值减少空指针判断
**错误示例**:
```go
func GetUser() (*User, error){
    // ...
    return nil, nil
}

user, err := GetUser()
if err != nil{
    // handle err
    reutrn err
}

// user == nil
name := user.Name // panic
```
**正确示例**:
```go
func GetUser() (*User, error){...}

user, err := GetUser()
if err != nil{
    // handle err
    return
}

// user != nil
name := user.Name
```
**正确示例**:
```go
func GetUser() (*User, bool){...}
user, ok := GetUser()
if !ok{
    return
}

// user != nil
name := user.Name
```
### 二、数组越界
#### 1. 直接使用数组或切片，必须判断下标是否越界
**正确示例**：
```go
var friends []int = getFriends()

i := 10

// check range of index
if i > len(friends) - 1{
    return 
}

// safe index
friend := friends[i] 
```


##### 2. struct内部的数组和切片尽量封装起来，在内部做越界判断
**正确示例**：
```go
type User struct{
    friends []string
}

func (u *User)GetFriends(i int) (string, error){
    if i > len(u.friends) - 1{
        return "", errors.New("index out of range")
    }
    
    ...
}
```
### 三、异常捕获
##### 1. 所有goroutine必须recover panic
**正确示例**:
```go
func asyncFunc(){
    defer func() {
	    if x := recover(); x != nil {
	        logger.Error("caught panic, x)
	    }
    }()
    
    ...
}

go asyncFunc()
```
